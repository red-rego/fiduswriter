(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[4],{

/***/ "./js/modules/exporter/tools/doc_contents.js":
/*!***************************************************!*\
  !*** ./js/modules/exporter/tools/doc_contents.js ***!
  \***************************************************/
/*! exports provided: removeHidden, descendantNodes, textContent, fixTables */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeHidden\", function() { return removeHidden; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"descendantNodes\", function() { return descendantNodes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"textContent\", function() { return textContent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fixTables\", function() { return fixTables; });\n// Return a json that is the same as the existing json, but with all parts\n// marked as hidden removed.\nvar removeHidden = function removeHidden(node) {\n  var leaveStub = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var returnNode = {};\n  Object.keys(node).forEach(function (key) {\n    if (key !== 'content') {\n      returnNode[key] = node[key];\n    }\n  });\n\n  if (node.attrs && node.attrs.hidden) {\n    if (leaveStub) {\n      return returnNode;\n    } else {\n      return false;\n    }\n  }\n\n  if (node.content) {\n    returnNode.content = [];\n    node.content.forEach(function (child) {\n      var cleanedChild = removeHidden(child, leaveStub);\n\n      if (cleanedChild) {\n        returnNode.content.push(cleanedChild);\n      }\n    });\n  }\n\n  return returnNode;\n};\nvar descendantNodes = function descendantNodes(node) {\n  var returnValue = [node];\n\n  if (node.content) {\n    node.content.forEach(function (childNode) {\n      returnValue = returnValue.concat(descendantNodes(childNode));\n    });\n  }\n\n  return returnValue;\n};\nvar textContent = function textContent(node) {\n  return descendantNodes(node).reduce(function (returnString, subNode) {\n    if (subNode.text) {\n      returnString += subNode.text;\n    }\n\n    return returnString;\n  }, '');\n}; // PM/HTML don't have cells that have been covered, but in ODT/DOCX, these cells\n// need to be present. So we add them.\n\nvar addCoveredTableCells = function addCoveredTableCells(node) {\n  var columns = node.content[0].content.reduce(function (columns, cell) {\n    return columns + cell.attrs.colspan;\n  }, 0);\n  var rows = node.content.length; // Add empty cells for col/rowspan\n\n  var fixedTableMatrix = Array.apply(0, {\n    length: rows\n  }).map(function (_item) {\n    return {\n      type: 'table_row',\n      content: Array.apply(0, {\n        length: columns\n      })\n    };\n  });\n  var rowIndex = -1;\n  node.content.forEach(function (row) {\n    var columnIndex = 0;\n    rowIndex++;\n\n    if (!row.content) {\n      return;\n    }\n\n    row.content.forEach(function (cell) {\n      while (fixedTableMatrix[rowIndex].content[columnIndex]) {\n        columnIndex++;\n      }\n\n      for (var i = 0; i < cell.attrs.rowspan; i++) {\n        for (var j = 0; j < cell.attrs.colspan; j++) {\n          var fixedCell = void 0;\n\n          if (i === 0 && j === 0) {\n            fixedCell = cell;\n          } else {\n            fixedCell = {\n              type: 'table_cell',\n              attrs: {\n                rowspan: cell.attrs.rowspan > 1 ? 0 : 1,\n                colspan: cell.attrs.colspan > 1 ? 0 : 1\n              }\n            };\n          }\n\n          fixedTableMatrix[rowIndex + i].content[columnIndex + j] = fixedCell;\n        }\n      }\n    });\n  });\n  node.content = fixedTableMatrix;\n};\n\nvar fixTables = function fixTables(node) {\n  if (node.type === 'table') {\n    addCoveredTableCells(node);\n  }\n\n  if (node.content) {\n    node.content.forEach(function (child) {\n      return fixTables(child);\n    });\n  }\n\n  return node;\n};\n\n//# sourceURL=webpack:///./js/modules/exporter/tools/doc_contents.js?");

/***/ }),

/***/ "./js/modules/exporter/tools/dom_export.js":
/*!*************************************************!*\
  !*** ./js/modules/exporter/tools/dom_export.js ***!
  \*************************************************/
/*! exports provided: BaseDOMExporter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BaseDOMExporter\", function() { return BaseDOMExporter; });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _citations_render__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../citations/render */ \"./js/modules/citations/render.js\");\n/* harmony import */ var _schema_i18n__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../schema/i18n */ \"./js/modules/schema/i18n.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n/*\n\nWARNING: DEPRECATED!\n\nBase exporter class for dom-based exports. This is the deprecated way of creating exports.\nThe epub, html and print export filters go over a DOM of a document which they change little\nby little, and they are all based on the BaseDOMExporter class.\n\n    New exporters should instead by walking the doc.contents tree.\n    This is how the LaTeX, ODT and DOCX export filters work.\n*/\n\nvar BaseDOMExporter =\n/*#__PURE__*/\nfunction () {\n  function BaseDOMExporter(schema) {\n    _classCallCheck(this, BaseDOMExporter);\n\n    this.schema = schema;\n  }\n\n  _createClass(BaseDOMExporter, [{\n    key: \"joinDocumentParts\",\n    value: function joinDocumentParts() {\n      var _this = this;\n\n      this.schema.cached.imageDB = this.imageDB;\n      var serializer = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__[\"DOMSerializer\"].fromSchema(this.schema);\n      this.contents = serializer.serializeNode(this.schema.nodeFromJSON(this.docContents));\n      var settings = this.exporter.doc.settings,\n          bibliographyHeader = settings.bibliography_header[settings.language] || _schema_i18n__WEBPACK_IMPORTED_MODULE_2__[\"BIBLIOGRAPHY_HEADERS\"][settings.language];\n      var citRenderer = new _citations_render__WEBPACK_IMPORTED_MODULE_1__[\"RenderCitations\"](this.contents, this.doc.settings.citationstyle, bibliographyHeader, this.bibDB, this.citationStyles, this.citationLocales);\n      return citRenderer.init().then(function () {\n        _this.addBibliographyHTML(citRenderer.fm.bibHTML);\n\n        _this.cleanHTML(citRenderer.fm);\n\n        return Promise.resolve();\n      });\n    }\n  }, {\n    key: \"addBibliographyHTML\",\n    value: function addBibliographyHTML(bibliographyHTML) {\n      if (bibliographyHTML.length > 0) {\n        var tempNode = document.createElement('div');\n        tempNode.innerHTML = bibliographyHTML;\n\n        while (tempNode.firstChild) {\n          this.contents.appendChild(tempNode.firstChild);\n        }\n      }\n    }\n  }, {\n    key: \"addFigureNumbers\",\n    value: function addFigureNumbers(htmlEl) {\n      htmlEl.querySelectorAll('figcaption .figure-cat-figure').forEach(function (el, index) {\n        el.innerHTML += ' ' + (index + 1) + ': ';\n      });\n      htmlEl.querySelectorAll('figcaption .figure-cat-photo').forEach(function (el, index) {\n        el.innerHTML += ' ' + (index + 1) + ': ';\n      });\n      htmlEl.querySelectorAll('figcaption .figure-cat-table').forEach(function (el, index) {\n        el.innerHTML += ' ' + (index + 1) + ': ';\n      });\n      return htmlEl;\n    }\n  }, {\n    key: \"replaceImgSrc\",\n    value: function replaceImgSrc(htmlString) {\n      htmlString = htmlString.replace(/<(img|IMG) data-src([^>]+)>/gm, \"<$1 src$2>\");\n      return htmlString;\n    } // Replace all instances of the before string in all descendant textnodes of\n    // node.\n\n  }, {\n    key: \"replaceText\",\n    value: function replaceText(node, before, after) {\n      var _this2 = this;\n\n      if (node.nodeType === 1) {\n        [].forEach.call(node.childNodes, function (child) {\n          return _this2.replaceText(child, before, after);\n        });\n      } else if (node.nodeType === 3) {\n        node.textContent = node.textContent.replace(window.RegExp(before, 'g'), after);\n      }\n    }\n  }, {\n    key: \"cleanNode\",\n    value: function cleanNode(node) {\n      var _this3 = this;\n\n      if (node.contentEditable === 'true') {\n        node.removeAttribute('contentEditable');\n      }\n\n      if (node.children) {\n        Array.from(node.children).forEach(function (childNode) {\n          return _this3.cleanNode(childNode);\n        });\n      }\n    }\n  }, {\n    key: \"getFootnoteAnchor\",\n    value: function getFootnoteAnchor(counter) {\n      var footnoteAnchor = document.createElement('a');\n      footnoteAnchor.setAttribute('href', '#fn' + counter); // RASH 0.5 doesn't mark the footnote anchors, so we add this class\n\n      footnoteAnchor.classList.add('fn');\n      return footnoteAnchor;\n    }\n  }, {\n    key: \"cleanHTML\",\n    value: function cleanHTML(citationFormatter) {\n      var _this4 = this;\n\n      var footnoteSelector = citationFormatter.citationType === 'note' ? '.footnote-marker, .citation' : '.footnote-marker'; // Replace the footnote markers with anchors and put footnotes with contents\n      // at the back of the document.\n      // Also, link the footnote anchor with the footnote according to\n      // https://rawgit.com/essepuntato/rash/master/documentation/index.html#footnotes.\n\n      var footnotes = this.contents.querySelectorAll(footnoteSelector);\n      var footnotesContainer = document.createElement('section');\n      var citationCount = 0;\n      footnotesContainer.classList.add('fnlist');\n      footnotesContainer.setAttribute('role', 'doc-footnotes');\n      footnotes.forEach(function (footnote, index) {\n        var counter = index + 1;\n\n        var footnoteAnchor = _this4.getFootnoteAnchor(counter);\n\n        footnote.parentNode.replaceChild(footnoteAnchor, footnote);\n        var newFootnote = document.createElement('section');\n        newFootnote.id = 'fn' + counter;\n        newFootnote.setAttribute('role', 'doc-footnote');\n        newFootnote.innerHTML = footnote.matches('.footnote-marker') ? footnote.dataset.footnote : \"<p>\".concat(citationFormatter.citationTexts[citationCount++] || \" \", \"</p>\");\n        footnotesContainer.appendChild(newFootnote);\n      });\n      this.contents.appendChild(footnotesContainer);\n      this.cleanNode(this.contents); // Replace nbsp spaces with normal ones\n\n      this.replaceText(this.contents, '&nbsp;', ' ');\n      this.contents.querySelectorAll('.comment').forEach(function (el) {\n        el.insertAdjacentHTML('afterend', el.innerHTML);\n        el.parentElement.removeChild(el);\n      });\n      this.contents.querySelectorAll('.citation').forEach(function (el) {\n        delete el.dataset.references;\n        delete el.dataset.bibs;\n        delete el.dataset.format;\n      });\n      this.contents.querySelectorAll('.equation, .figure-equation').forEach(function (el) {\n        delete el.dataset.equation;\n      });\n      this.contents.querySelectorAll('.figure').forEach(function (el) {\n        delete el.dataset.equation;\n        delete el.dataset.image;\n        delete el.dataset.figureCategory;\n        delete el.dataset.caption;\n      });\n      this.contents.querySelectorAll('.figure-cat-figure').forEach(function (el) {\n        delete el.dataset.figureCategory;\n      });\n    } // Fill the contents of table of contents.\n\n  }, {\n    key: \"fillToc\",\n    value: function fillToc() {\n      var headlines = Array.from(this.contents.querySelectorAll('h1,h2,h3,h4,h5,h6'));\n      var tocs = Array.from(this.contents.querySelectorAll('div.table-of-contents'));\n      tocs.forEach(function (toc) {\n        toc.innerHTML += headlines.map(function (headline) {\n          if (!headline.id || !headline.textContent.length) {\n            // ignore the tocs own headlines\n            return '';\n          }\n\n          var tagName = headline.tagName.toLowerCase();\n          return \"<\".concat(tagName, \"><a href=\\\"#\").concat(headline.id, \"\\\">\").concat(headline.innerHTML, \"</a></\").concat(tagName, \">\");\n        }).join('');\n      });\n    }\n  }]);\n\n  return BaseDOMExporter;\n}();\n\n//# sourceURL=webpack:///./js/modules/exporter/tools/dom_export.js?");

/***/ }),

/***/ "./js/modules/exporter/tools/html.js":
/*!*******************************************!*\
  !*** ./js/modules/exporter/tools/html.js ***!
  \*******************************************/
/*! exports provided: modifyImages */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"modifyImages\", function() { return modifyImages; });\nvar modifyImages = function modifyImages(htmlEl) {\n  var imageLinks = htmlEl.querySelectorAll('img'),\n      images = [];\n  imageLinks.forEach(function (el, index) {\n    var src = el.getAttribute('src').split('?')[0];\n    var name = src.split('/').pop(); // JPGs are output as PNG elements as well.\n\n    if (name === '') {\n      // name was not retrievable so we give the image a unique numerical\n      // name like 1.png, 2.jpg, 3.svg, etc. .\n      name = index;\n    }\n\n    var newImg = document.createElement('img'); // We set the src of the image as \"data-src\" for now so that the browser\n    // won't try to load the file immediately\n\n    newImg.setAttribute('data-src', name);\n    el.parentNode.replaceChild(newImg, el);\n\n    if (!images.find(function (image) {\n      return image.filename === name;\n    })) {\n      images.push({\n        filename: name,\n        url: src\n      });\n    }\n  });\n  return images;\n};\n\n//# sourceURL=webpack:///./js/modules/exporter/tools/html.js?");

/***/ })

}]);
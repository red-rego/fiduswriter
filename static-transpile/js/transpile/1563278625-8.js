(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[8],{

/***/ "./js/modules/bibliography/schema/common.js":
/*!**************************************************!*\
  !*** ./js/modules/bibliography/schema/common.js ***!
  \**************************************************/
/*! exports provided: text, literal, variable, sup, sub, smallcaps, url, enquote */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"text\", function() { return text; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"literal\", function() { return literal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"variable\", function() { return variable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sup\", function() { return sup; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"smallcaps\", function() { return smallcaps; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"url\", function() { return url; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"enquote\", function() { return enquote; });\nvar text = {\n  group: \"inline\"\n};\nvar literal = {\n  content: \"inline*\",\n  marks: \"_\",\n  parseDOM: [{\n    tag: 'div.literal'\n  }],\n  toDOM: function toDOM() {\n    return [\"div\", {\n      \"class\": 'literal'\n    }, 0];\n  }\n};\nvar variable = {\n  inline: true,\n  group: \"inline\",\n  attrs: {\n    variable: {\n      \"default\": \"\"\n    }\n  },\n  parseDOM: [{\n    tag: 'span[data-variable]',\n    getAttrs: function getAttrs(dom) {\n      return {\n        variable: dom.getAttribute(\"data-variable\")\n      };\n    }\n  }],\n  toDOM: function toDOM(node) {\n    return [\"span\", {\n      'data-variable': node.attrs.variable\n    }, node.attrs.variable];\n  }\n};\nvar sup = {\n  parseDOM: [{\n    tag: 'sup'\n  }, {\n    style: \"vertical-align\",\n    getAttrs: function getAttrs(value) {\n      return value == \"super\" && null;\n    }\n  }],\n  toDOM: function toDOM() {\n    return [\"sup\"];\n  }\n};\nvar sub = {\n  parseDOM: [{\n    tag: 'sub'\n  }, {\n    style: \"vertical-align\",\n    getAttrs: function getAttrs(value) {\n      return value == \"sub\" && null;\n    }\n  }],\n  toDOM: function toDOM() {\n    return [\"sub\"];\n  }\n};\nvar smallcaps = {\n  parseDOM: [{\n    tag: 'span.smallcaps'\n  }, {\n    style: \"font-variant\",\n    getAttrs: function getAttrs(value) {\n      return value == \"small-caps\" && null;\n    }\n  }],\n  toDOM: function toDOM() {\n    return [\"span\", {\n      \"class\": \"smallcaps\"\n    }];\n  }\n}; //Currently unsupported\n\nvar url = {\n  parseDOM: [{\n    tag: 'span.url'\n  }],\n  toDOM: function toDOM() {\n    return [\"span\", {\n      \"class\": \"url\"\n    }];\n  }\n};\nvar enquote = {\n  parseDOM: [{\n    tag: 'span.enquote'\n  }],\n  toDOM: function toDOM() {\n    return [\"span\", {\n      \"class\": \"enquote\"\n    }];\n  }\n};\n\n//# sourceURL=webpack:///./js/modules/bibliography/schema/common.js?");

/***/ }),

/***/ "./js/modules/bibliography/schema/csl_bib.js":
/*!***************************************************!*\
  !*** ./js/modules/bibliography/schema/csl_bib.js ***!
  \***************************************************/
/*! exports provided: cslBibSchema */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cslBibSchema\", function() { return cslBibSchema; });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./js/modules/bibliography/schema/common.js\");\n/* harmony import */ var prosemirror_schema_basic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-schema-basic */ \"./node_modules/prosemirror-schema-basic/dist/schema-basic.js\");\n/* harmony import */ var prosemirror_schema_basic__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prosemirror_schema_basic__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-model */ \"./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prosemirror_model__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nvar doc = {\n  content: \"cslbib\"\n};\nvar cslbib = {\n  content: \"cslentry*\",\n  parseDOM: [{\n    tag: 'div.csl-bib-body'\n  }],\n  toDOM: function toDOM(_node) {\n    return [\"div\", {\n      \"class\": 'csl-bib-body'\n    }, 0];\n  }\n};\nvar cslentry = {\n  content: \"block*\",\n  parseDOM: [{\n    tag: 'div.csl-entry'\n  }],\n  toDOM: function toDOM(_node) {\n    return [\"div\", {\n      \"class\": 'csl-entry'\n    }, 0];\n  }\n}; // This block doesn't actually appear in the HTML output, but because the schema\n// system doesn't allow for the mixing of inline and block content, it \"imagines\"\n// that this block exists. This---rather than other blocks---is chosen, because\n// it's the first in the list.\n\nvar cslinline = {\n  group: \"block\",\n  content: \"text*\",\n  marks: \"_\",\n  parseDOM: [{\n    tag: 'div.csl-inline'\n  }],\n  toDOM: function toDOM(_node) {\n    return [\"div\", {\n      \"class\": 'csl-inline'\n    }, 0];\n  }\n};\nvar cslblock = {\n  group: \"block\",\n  content: \"text*\",\n  marks: \"_\",\n  parseDOM: [{\n    tag: 'div.csl-block'\n  }],\n  toDOM: function toDOM(_node) {\n    return [\"div\", {\n      \"class\": 'csl-block'\n    }, 0];\n  }\n};\nvar cslleftmargin = {\n  group: \"block\",\n  content: \"text*\",\n  marks: \"_\",\n  parseDOM: [{\n    tag: 'div.csl-left-margin'\n  }],\n  toDOM: function toDOM(_node) {\n    return [\"div\", {\n      \"class\": 'csl-left-margin'\n    }, 0];\n  }\n};\nvar cslrightinline = {\n  group: \"block\",\n  content: \"text*\",\n  marks: \"_\",\n  parseDOM: [{\n    tag: 'div.csl-right-inline'\n  }],\n  toDOM: function toDOM(_node) {\n    return [\"div\", {\n      \"class\": 'csl-right-inline'\n    }, 0];\n  }\n};\nvar cslindent = {\n  group: \"block\",\n  content: \"text*\",\n  marks: \"_\",\n  parseDOM: [{\n    tag: 'div.csl-indent'\n  }],\n  toDOM: function toDOM(_node) {\n    return [\"div\", {\n      \"class\": 'csl-indent'\n    }, 0];\n  }\n}; // A schema to express the citeproc HTML bibliography output\n\nvar cslBibSchema = new prosemirror_model__WEBPACK_IMPORTED_MODULE_2__[\"Schema\"]({\n  nodes: {\n    doc: doc,\n    cslbib: cslbib,\n    cslentry: cslentry,\n    cslinline: cslinline,\n    cslblock: cslblock,\n    cslleftmargin: cslleftmargin,\n    cslrightinline: cslrightinline,\n    cslindent: cslindent,\n    text: _common__WEBPACK_IMPORTED_MODULE_0__[\"text\"]\n  },\n  marks: {\n    em: prosemirror_schema_basic__WEBPACK_IMPORTED_MODULE_1__[\"marks\"].em,\n    strong: prosemirror_schema_basic__WEBPACK_IMPORTED_MODULE_1__[\"marks\"].strong,\n    smallcaps: _common__WEBPACK_IMPORTED_MODULE_0__[\"smallcaps\"],\n    sup: _common__WEBPACK_IMPORTED_MODULE_0__[\"sup\"],\n    sub: _common__WEBPACK_IMPORTED_MODULE_0__[\"sub\"]\n  }\n});\n\n//# sourceURL=webpack:///./js/modules/bibliography/schema/csl_bib.js?");

/***/ }),

/***/ "./js/modules/exporter/tools/doc_contents.js":
/*!***************************************************!*\
  !*** ./js/modules/exporter/tools/doc_contents.js ***!
  \***************************************************/
/*! exports provided: removeHidden, descendantNodes, textContent, fixTables */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeHidden\", function() { return removeHidden; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"descendantNodes\", function() { return descendantNodes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"textContent\", function() { return textContent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fixTables\", function() { return fixTables; });\n// Return a json that is the same as the existing json, but with all parts\n// marked as hidden removed.\nvar removeHidden = function removeHidden(node) {\n  var leaveStub = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var returnNode = {};\n  Object.keys(node).forEach(function (key) {\n    if (key !== 'content') {\n      returnNode[key] = node[key];\n    }\n  });\n\n  if (node.attrs && node.attrs.hidden) {\n    if (leaveStub) {\n      return returnNode;\n    } else {\n      return false;\n    }\n  }\n\n  if (node.content) {\n    returnNode.content = [];\n    node.content.forEach(function (child) {\n      var cleanedChild = removeHidden(child, leaveStub);\n\n      if (cleanedChild) {\n        returnNode.content.push(cleanedChild);\n      }\n    });\n  }\n\n  return returnNode;\n};\nvar descendantNodes = function descendantNodes(node) {\n  var returnValue = [node];\n\n  if (node.content) {\n    node.content.forEach(function (childNode) {\n      returnValue = returnValue.concat(descendantNodes(childNode));\n    });\n  }\n\n  return returnValue;\n};\nvar textContent = function textContent(node) {\n  return descendantNodes(node).reduce(function (returnString, subNode) {\n    if (subNode.text) {\n      returnString += subNode.text;\n    }\n\n    return returnString;\n  }, '');\n}; // PM/HTML don't have cells that have been covered, but in ODT/DOCX, these cells\n// need to be present. So we add them.\n\nvar addCoveredTableCells = function addCoveredTableCells(node) {\n  var columns = node.content[0].content.reduce(function (columns, cell) {\n    return columns + cell.attrs.colspan;\n  }, 0);\n  var rows = node.content.length; // Add empty cells for col/rowspan\n\n  var fixedTableMatrix = Array.apply(0, {\n    length: rows\n  }).map(function (_item) {\n    return {\n      type: 'table_row',\n      content: Array.apply(0, {\n        length: columns\n      })\n    };\n  });\n  var rowIndex = -1;\n  node.content.forEach(function (row) {\n    var columnIndex = 0;\n    rowIndex++;\n\n    if (!row.content) {\n      return;\n    }\n\n    row.content.forEach(function (cell) {\n      while (fixedTableMatrix[rowIndex].content[columnIndex]) {\n        columnIndex++;\n      }\n\n      for (var i = 0; i < cell.attrs.rowspan; i++) {\n        for (var j = 0; j < cell.attrs.colspan; j++) {\n          var fixedCell = void 0;\n\n          if (i === 0 && j === 0) {\n            fixedCell = cell;\n          } else {\n            fixedCell = {\n              type: 'table_cell',\n              attrs: {\n                rowspan: cell.attrs.rowspan > 1 ? 0 : 1,\n                colspan: cell.attrs.colspan > 1 ? 0 : 1\n              }\n            };\n          }\n\n          fixedTableMatrix[rowIndex + i].content[columnIndex + j] = fixedCell;\n        }\n      }\n    });\n  });\n  node.content = fixedTableMatrix;\n};\n\nvar fixTables = function fixTables(node) {\n  if (node.type === 'table') {\n    addCoveredTableCells(node);\n  }\n\n  if (node.content) {\n    node.content.forEach(function (child) {\n      return fixTables(child);\n    });\n  }\n\n  return node;\n};\n\n//# sourceURL=webpack:///./js/modules/exporter/tools/doc_contents.js?");

/***/ }),

/***/ "./js/modules/exporter/tools/xml_zip.js":
/*!**********************************************!*\
  !*** ./js/modules/exporter/tools/xml_zip.js ***!
  \**********************************************/
/*! exports provided: XmlZip */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"XmlZip\", function() { return XmlZip; });\n/* harmony import */ var downloadjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! downloadjs */ \"./node_modules/downloadjs/download.js\");\n/* harmony import */ var downloadjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(downloadjs__WEBPACK_IMPORTED_MODULE_0__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n // Handle a zip file containing XML files. Make sure files are only opened once,\n// and provide a mechanism to save the file.\n\nvar XmlZip =\n/*#__PURE__*/\nfunction () {\n  function XmlZip(fileName, url, mimeType) {\n    _classCallCheck(this, XmlZip);\n\n    this.fileName = fileName;\n    this.url = url;\n    this.mimeType = mimeType;\n    this.docs = {};\n    this.extraFiles = {};\n    this.rawFile = false;\n  }\n\n  _createClass(XmlZip, [{\n    key: \"init\",\n    value: function init() {\n      var _this = this;\n\n      return __webpack_require__.e(/*! import() */ 5).then(__webpack_require__.t.bind(null, /*! jszip */ \"./node_modules/jszip/lib/index.js\", 7)).then(function (_ref) {\n        var JSZip = _ref[\"default\"];\n        _this.zip = new JSZip();\n        return _this.downloadZip();\n      }).then(function () {\n        return _this.loadZip();\n      });\n    }\n  }, {\n    key: \"downloadZip\",\n    value: function downloadZip() {\n      var _this2 = this;\n\n      return new Promise(function (resolve) {\n        __webpack_require__.e(/*! import() */ 1).then(__webpack_require__.t.bind(null, /*! jszip-utils */ \"./node_modules/jszip-utils/lib/index.js\", 7)).then(function (_ref2) {\n          var JSZipUtils = _ref2[\"default\"];\n          return JSZipUtils.getBinaryContent(_this2.url, function (err, rawFile) {\n            _this2.rawFile = rawFile;\n            resolve();\n          });\n        });\n      });\n    }\n  }, {\n    key: \"loadZip\",\n    value: function loadZip() {\n      return this.zip.loadAsync(this.rawFile);\n    } // Open file at filePath from zip file and parse it as XML.\n\n  }, {\n    key: \"getXml\",\n    value: function getXml(filePath, defaultContents) {\n      var _this3 = this;\n\n      if (this.docs[filePath]) {\n        // file has been loaded already.\n        return Promise.resolve(this.docs[filePath]);\n      } else if (this.zip.files[filePath]) {\n        return this.zip.file(filePath).async('string').then(function (string) {\n          var parser = new window.DOMParser();\n          _this3.docs[filePath] = parser.parseFromString(string, \"text/xml\");\n          return Promise.resolve(_this3.docs[filePath]);\n        });\n      } else if (defaultContents) {\n        return Promise.resolve(defaultContents).then(function (string) {\n          var parser = new window.DOMParser();\n          _this3.docs[filePath] = parser.parseFromString(string, \"text/xml\");\n          return Promise.resolve(_this3.docs[filePath]);\n        });\n      } else {\n        // File couldn't be found and there was no default value.\n        return Promise.reject(new Error(\"File not found\"));\n      }\n    } // Add an xml file at filepath without checking for previous version\n\n  }, {\n    key: \"addXmlFile\",\n    value: function addXmlFile(filePath, xmlContents) {\n      this.docs[filePath] = xmlContents;\n    } // Add extra file to be saved in zip later.\n\n  }, {\n    key: \"addExtraFile\",\n    value: function addExtraFile(filePath, fileContents) {\n      this.extraFiles[filePath] = fileContents;\n    } // Put all currently open XML files into zip.\n\n  }, {\n    key: \"allXMLToZip\",\n    value: function allXMLToZip() {\n      for (var fileName in this.docs) {\n        this.xmlToZip(fileName);\n      }\n    } // Put all extra files into zip.\n\n  }, {\n    key: \"allExtraToZip\",\n    value: function allExtraToZip() {\n      for (var fileName in this.extraFiles) {\n        this.zip.file(fileName, this.extraFiles[fileName]);\n      }\n    } // Put the xml identified by filePath into zip.\n\n  }, {\n    key: \"xmlToZip\",\n    value: function xmlToZip(filePath) {\n      var serializer = new window.XMLSerializer();\n      var string = serializer.serializeToString(this.docs[filePath]);\n      this.zip.file(filePath, string);\n    }\n  }, {\n    key: \"prepareAndDownload\",\n    value: function prepareAndDownload() {\n      var _this4 = this;\n\n      this.allXMLToZip();\n      this.allExtraToZip();\n      this.zip.generateAsync({\n        type: \"blob\",\n        mimeType: this.mimeType\n      }).then(function (out) {\n        return downloadjs__WEBPACK_IMPORTED_MODULE_0___default()(out, _this4.fileName, _this4.mimeType);\n      });\n    }\n  }]);\n\n  return XmlZip;\n}();\n\n//# sourceURL=webpack:///./js/modules/exporter/tools/xml_zip.js?");

/***/ }),

/***/ 0:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///util_(ignored)?");

/***/ }),

/***/ 1:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///util_(ignored)?");

/***/ })

}]);
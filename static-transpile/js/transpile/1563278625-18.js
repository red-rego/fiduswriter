(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[18],{

/***/ "./js/modules/exporter/latex/convert.js":
/*!**********************************************!*\
  !*** ./js/modules/exporter/latex/convert.js ***!
  \**********************************************/
/*! exports provided: LatexExporterConvert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LatexExporterConvert\", function() { return LatexExporterConvert; });\n/* harmony import */ var _escape_latex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./escape_latex */ \"./js/modules/exporter/latex/escape_latex.js\");\n/* harmony import */ var _schema_i18n__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../schema/i18n */ \"./js/modules/schema/i18n.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar LatexExporterConvert =\n/*#__PURE__*/\nfunction () {\n  function LatexExporterConvert(exporter, imageDB, bibDB) {\n    _classCallCheck(this, LatexExporterConvert);\n\n    this.exporter = exporter;\n    this.imageDB = imageDB;\n    this.bibDB = bibDB;\n    this.imageIds = [];\n    this.usedBibDB = {}; // While walking the tree, we take note of the kinds of features That\n    // are present in the file, so that we can assemble an preamble and\n    // epilogue based on our findings.\n\n    this.features = {};\n    this.internalLinks = [];\n  }\n\n  _createClass(LatexExporterConvert, [{\n    key: \"init\",\n    value: function init(docContents) {\n      this.preWalkJson(docContents);\n      var rawTransformation = this.walkJson(docContents);\n      var body = this.postProcess(rawTransformation);\n      var preamble = this.assemblePreamble();\n      var epilogue = this.assembleEpilogue();\n      var latex = this.docDeclaration + preamble + '\\n\\\\begin{document}\\n' + body + epilogue + '\\n\\\\end{document}\\n';\n      var returnObject = {\n        latex: latex,\n        imageIds: this.imageIds,\n        usedBibDB: this.usedBibDB\n      };\n      return returnObject;\n    }\n  }, {\n    key: \"preWalkJson\",\n    // Check for things needed before creating raw transofrm\n    value: function preWalkJson(node) {\n      var _this = this;\n\n      switch (node.type) {\n        // Collect all internal links so that we only set the anchors for those\n        // that are being linked to.\n        case 'text':\n          if (node.marks) {\n            var hyperlink = node.marks.find(function (mark) {\n              return mark.type === 'link';\n            });\n\n            if (hyperlink) {\n              var href = hyperlink.attrs.href;\n\n              if (href[0] === '#' && !this.internalLinks.includes(href)) {\n                this.internalLinks.push(href.slice(1));\n              }\n            }\n          }\n\n          break;\n      }\n\n      if (node.content) {\n        node.content.forEach(function (child) {\n          return _this.preWalkJson(child);\n        });\n      }\n    }\n  }, {\n    key: \"walkJson\",\n    value: function walkJson(node) {\n      var _this2 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var start = '',\n          content = '',\n          end = '',\n          placeFootnotesAfterBlock = false;\n\n      switch (node.type) {\n        case 'article':\n          break;\n\n        case 'title':\n          start += '\\n\\\\title{';\n          end = '}' + end;\n          break;\n\n        case 'heading_part':\n          if (node.attrs.metadata === 'subtitle' && node.content) {\n            start += '\\n\\\\subtitle{';\n            end = '}' + end;\n            this.features.subtitle = true;\n            options = Object.assign({}, options);\n            options.ignoreHeading = true;\n          } else if (!options.madeTitle) {\n            start += '\\n\\n\\\\maketitle\\n';\n            options.madeTitle = true;\n          }\n\n          break;\n\n        case 'contributor':\n          // Ignore - we deal with namelist_part instead.\n          break;\n\n        case 'contributors_part':\n          if (node.content) {\n            if (node.attrs.metadata === 'authors') {\n              var authorsPerAffil = node.content.map(function (node) {\n                var author = node.attrs,\n                    nameParts = [];\n                var affiliation = false;\n\n                if (author.firstname) {\n                  nameParts.push(author.firstname);\n                }\n\n                if (author.lastname) {\n                  nameParts.push(author.lastname);\n                }\n\n                if (nameParts.length && author.institution) {\n                  affiliation = author.institution;\n                } else if (author.institution) {\n                  // We have an institution but no names. Use institution as name.\n                  nameParts.push(author.institution);\n                }\n\n                return {\n                  name: nameParts.join(' '),\n                  affiliation: affiliation,\n                  email: author.email\n                };\n              }).reduce(function (affils, author) {\n                var affil = author.affiliation;\n                affils[affil] = affils[affil] || [];\n                affils[affil].push(author);\n                return affils;\n              }, {});\n              Object.values(authorsPerAffil).forEach(function (affil) {\n                affil.forEach(function (author) {\n                  content += \"\\n\\\\author{\".concat(Object(_escape_latex__WEBPACK_IMPORTED_MODULE_0__[\"escapeLatexText\"])(author.name)).concat(author.email ? \"\\\\thanks{\".concat(Object(_escape_latex__WEBPACK_IMPORTED_MODULE_0__[\"escapeLatexText\"])(author.email), \"}\") : '', \"}\");\n                });\n                content += \"\\n\\\\affil{\".concat(affil[0].affiliation ? Object(_escape_latex__WEBPACK_IMPORTED_MODULE_0__[\"escapeLatexText\"])(affil[0].affiliation) : '', \"}\");\n              });\n              this.features.authors = true;\n            } else {\n              if (!options.madeTitle) {\n                start += '\\n\\n\\\\maketitle\\n';\n                options.madeTitle = true;\n              } // TODO: deal with contributor lists of non-authors properly\n\n\n              content += node.content.map(function (contributorNode) {\n                var nameParts = [];\n\n                if (contributorNode.attrs.firstname) {\n                  nameParts.push(contributorNode.attrs.firstname);\n                }\n\n                if (contributorNode.attrs.lastname) {\n                  nameParts.push(contributorNode.attrs.lastname);\n                }\n\n                if (!nameParts.length && contributorNode.attrs.institution) {\n                  // We have an institution but no names. Use institution as name.\n                  nameParts.push(contributorNode.attrs.institution);\n                }\n\n                return nameParts.join(' ');\n              }).join(', ');\n            }\n\n            content += \"\\n\\n\";\n          }\n\n          break;\n\n        case 'tags_part':\n          if (node.content) {\n            if (node.attrs.metadata === 'keywords') {\n              start += '\\n\\\\keywords{';\n              start += node.content.map(function (keyword) {\n                return Object(_escape_latex__WEBPACK_IMPORTED_MODULE_0__[\"escapeLatexText\"])(keyword.attrs.tag);\n              }).join('\\\\sep ');\n              end = '}' + end;\n              this.features.keywords = true;\n            } else if (!options.madeTitle) {\n              start += '\\n\\n\\\\maketitle\\n';\n              options.madeTitle = true;\n            }\n          }\n\n          break;\n\n        case 'tag':\n          // Ignore - we already took all the tags_part from the keywords node.\n          break;\n\n        case 'richtext_part':\n          if (!options.madeTitle) {\n            start += '\\n\\n\\\\maketitle\\n';\n            options.madeTitle = true;\n          }\n\n          if (node.content && node.attrs.metadata === 'abstract') {\n            start += '\\n\\\\begin{abstract}\\n';\n            end = '\\n\\\\end{abstract}\\n' + end;\n          }\n\n          break;\n\n        case 'table_of_contents':\n          start += '\\n\\n\\\\tableofcontents\\n';\n          break;\n\n        case 'separator_part':\n        case 'table_part':\n          // part separators as in page breaks should usually already be handled\n          // by LaTeX and table parts will simply show the table inside of them.\n          break;\n\n        case 'paragraph':\n          start += '\\n\\n';\n          end = '\\n' + end;\n          break;\n\n        case 'heading1':\n        case 'heading2':\n        case 'heading3':\n        case 'heading4':\n        case 'heading5':\n        case 'heading6':\n          {\n            if (options.ignoreHeading) {\n              break;\n            }\n\n            var level = parseInt(node.type.slice(-1));\n\n            switch (level) {\n              case 1:\n                start += '\\n\\n\\\\section{';\n                break;\n\n              case 2:\n                start += '\\n\\n\\\\subsection{';\n                break;\n\n              case 3:\n              case 4:\n              case 5:\n              case 6:\n                // TODO: Add support for levels 4/5/6\n                start += '\\n\\n\\\\subsubsection{';\n                break;\n            } // Check if this heading is being linked to. If this is the case,\n            // place a protected hypertarget here that does not add an extra\n            // entry into the PDF TOC.\n\n\n            end = '}\\n\\n' + end;\n\n            if (this.internalLinks.includes(node.attrs.id)) {\n              // Add a link target\n              end = \"\\\\texorpdfstring{\\\\protect\\\\hypertarget{\".concat(node.attrs.id, \"}{}}{}\") + end;\n            }\n\n            if (!options.onlyFootnoteMarkers) {\n              placeFootnotesAfterBlock = true;\n              options = Object.assign({}, options);\n              options.onlyFootnoteMarkers = true;\n              options.unplacedFootnotes = [];\n            }\n\n            break;\n          }\n\n        case 'code':\n          start += '\\n\\\\begin{code}\\n\\n';\n          end = '\\n\\n\\\\end{code}\\n';\n          break;\n\n        case 'blockquote':\n          start += '\\n\\\\begin{quote}\\n\\n';\n          end = '\\n\\n\\\\end{quote}\\n';\n          break;\n\n        case 'ordered_list':\n          start += '\\n\\\\begin{enumerate}';\n          end = '\\n\\\\end{enumerate}' + end;\n\n          if (!options.onlyFootnoteMarkers) {\n            placeFootnotesAfterBlock = true;\n            options = Object.assign({}, options);\n            options.onlyFootnoteMarkers = true;\n            options.unplacedFootnotes = [];\n          }\n\n          break;\n\n        case 'bullet_list':\n          start += '\\n\\\\begin{itemize}';\n          end = '\\n\\\\end{itemize}' + end;\n\n          if (!options.onlyFootnoteMarkers) {\n            placeFootnotesAfterBlock = true;\n            options = Object.assign({}, options);\n            options.onlyFootnoteMarkers = true;\n            options.unplacedFootnotes = [];\n          }\n\n          break;\n\n        case 'list_item':\n          start += '\\n\\\\item ';\n          end = '\\n' + end;\n          break;\n\n        case 'footnote':\n          if (options.onlyFootnoteMarkers) {\n            // We are inside a headline or a list and can only place a\n            // footnote marker here. The footnote will have to be put\n            // beyond the block node instead.\n            start += '\\\\protect\\\\footnotemark{}';\n            options.unplacedFootnotes.push(node.attrs.footnote);\n          } else {\n            start += '\\\\footnote{';\n            var fnContent = '';\n            node.attrs.footnote.forEach(function (footPar) {\n              fnContent += _this2.walkJson(footPar, options);\n            });\n            content += fnContent.replace(/^\\s+|\\s+$/g, '');\n            end = '}' + end;\n          }\n\n          break;\n\n        case 'text':\n          {\n            var strong, em, underline, hyperlink; // Check for hyperlink, bold/strong, italic/em and underline\n\n            if (node.marks) {\n              strong = node.marks.find(function (mark) {\n                return mark.type === 'strong';\n              });\n              em = node.marks.find(function (mark) {\n                return mark.type === 'em';\n              });\n              underline = node.marks.find(function (mark) {\n                return mark.type === 'underline';\n              });\n              hyperlink = node.marks.find(function (mark) {\n                return mark.type === 'link';\n              });\n            }\n\n            if (em) {\n              start += '\\\\emph{';\n              end = '}' + end;\n            }\n\n            if (strong) {\n              start += '\\\\textbf{';\n              end = '}' + end;\n            }\n\n            if (underline) {\n              start += \"\\\\underline{\";\n              end = '}' + end;\n            }\n\n            if (hyperlink) {\n              var href = hyperlink.attrs.href;\n\n              if (href[0] === '#') {\n                // Internal link\n                start += \"\\\\hyperlink{\".concat(href.slice(1), \"}{\");\n              } else {\n                // External link\n                start += \"\\\\href{\".concat(href, \"}{\");\n              }\n\n              end = '}' + end;\n              this.features.hyperlinks = true;\n            }\n\n            content += Object(_escape_latex__WEBPACK_IMPORTED_MODULE_0__[\"escapeLatexText\"])(node.text);\n            break;\n          }\n\n        case 'citation':\n          {\n            var references = node.attrs.references;\n            var format = node.attrs.format;\n            var citationCommand = '\\\\' + format;\n\n            if (references.length > 1 && references.every(function (ref) {\n              return !ref.locator && !ref.prefix;\n            })) {\n              // multi source citation without page numbers or text before.\n              var citationEntryKeys = [];\n              var allCitationItemsPresent = references.map(function (ref) {\n                return ref.id;\n              }).every(function (citationEntry) {\n                var bibDBEntry = _this2.bibDB.db[citationEntry];\n\n                if (bibDBEntry) {\n                  if (!bibDBEntry) {\n                    // Not present in bibliography database, skip it.\n                    // TODO: Throw an error?\n                    return false;\n                  }\n\n                  if (!_this2.usedBibDB[citationEntry]) {\n                    var citationKey = _this2.createUniqueCitationKey(bibDBEntry.entry_key);\n\n                    _this2.usedBibDB[citationEntry] = Object.assign({}, bibDBEntry);\n                    _this2.usedBibDB[citationEntry].entry_key = citationKey;\n                  }\n\n                  citationEntryKeys.push(_this2.usedBibDB[citationEntry].entry_key);\n                }\n\n                return true;\n              });\n\n              if (allCitationItemsPresent) {\n                citationCommand += \"{\".concat(citationEntryKeys.join(','), \"}\");\n              } else {\n                citationCommand = false;\n              }\n            } else {\n              if (references.length > 1) {\n                citationCommand += 's'; // Switching from \\autocite to \\autocites\n              }\n\n              var _allCitationItemsPresent = references.every(function (ref) {\n                var bibDBEntry = _this2.bibDB.db[ref.id];\n\n                if (!bibDBEntry) {\n                  // Not present in bibliography database, skip it.\n                  // TODO: Throw an error?\n                  return false;\n                }\n\n                if (ref.prefix) {\n                  citationCommand += \"[\".concat(ref.prefix, \"]\");\n\n                  if (!ref.locator) {\n                    citationCommand += '[]';\n                  }\n                }\n\n                if (ref.locator) {\n                  citationCommand += \"[\".concat(ref.locator, \"]\");\n                }\n\n                citationCommand += '{';\n\n                if (!_this2.usedBibDB[ref.id]) {\n                  var citationKey = _this2.createUniqueCitationKey(bibDBEntry.entry_key);\n\n                  _this2.usedBibDB[ref.id] = Object.assign({}, bibDBEntry);\n                  _this2.usedBibDB[ref.id].entry_key = citationKey;\n                }\n\n                citationCommand += _this2.usedBibDB[ref.id].entry_key;\n                citationCommand += '}';\n                return true;\n              });\n\n              if (!_allCitationItemsPresent) {\n                citationCommand = false;\n              }\n            }\n\n            if (citationCommand) {\n              content += citationCommand;\n              this.features.citations = true;\n            }\n\n            break;\n          }\n\n        case 'figure':\n          {\n            var figureType = node.attrs.figureCategory;\n            var caption = node.attrs.caption;\n            var innerFigure = '';\n            var aligned = 'left';\n\n            if (node.attrs.width !== '100') {\n              aligned = node.attrs.aligned;\n            }\n\n            if (aligned === 'center') {\n              start += '\\n\\n\\\\begin{center}';\n              end = '\\n\\n\\\\end{center}\\n' + end;\n            } else if (aligned === 'right') {\n              start += '\\n\\n{\\\\raggedleft'; // This is not a typo - raggedleft = aligned: right\n\n              end = '\\n\\n}\\n';\n            } // aligned === 'left' is default\n\n\n            if (node.attrs.image) {\n              this.imageIds.push(node.attrs.image);\n              var imageDBEntry = this.imageDB.db[node.attrs.image],\n                  filePathName = imageDBEntry.image,\n                  filename = filePathName.split('/').pop();\n\n              if (filename.split('.').pop() === 'svg') {\n                innerFigure += \"\\\\includesvg[width=\".concat(parseInt(node.attrs.width) / 100, \"\\\\textwidth]{\").concat(filename, \"}\\n\");\n                this.features.SVGs = true;\n              } else {\n                innerFigure += \"\\\\scaledgraphics{\".concat(filename, \"}{\").concat(parseInt(node.attrs.width) / 100, \"}\\n\");\n                this.features.images = true;\n              }\n            } else {\n              var equation = node.attrs.equation;\n              innerFigure += \"\\\\begin{displaymath}\\n\".concat(equation, \"\\n\\\\end{displaymath}\\n\");\n            }\n\n            if (figureType === 'table') {\n              start += \"\\n\\\\begin{table}\\n\";\n              content += \"\\\\caption{\".concat(caption, \"}\\n\").concat(innerFigure);\n              end = \"\\\\end{table}\\n\" + end;\n            } else {\n              // TODO: handle photo figure types in a special way\n              start += \"\\n\\\\begin{figure}\\n\";\n              content += \"\".concat(innerFigure, \"\\\\caption{\").concat(caption, \"}\\n\");\n              end = \"\\\\end{figure}\\n\" + end;\n            }\n\n            if (this.internalLinks.includes(node.attrs.id)) {\n              // Add a link target\n              end = \"\\\\texorpdfstring{\\\\protect\\\\hypertarget{\".concat(node.attrs.id, \"}{}}{}\\n\") + end;\n            }\n\n            break;\n          }\n\n        case 'table':\n          if (node.content && node.content.length) {\n            var columns = node.content[0].content.reduce(function (columns, node) {\n              return columns + node.attrs.colspan;\n            }, 0);\n            var _aligned = 'left';\n\n            if (node.attrs.width !== '100') {\n              _aligned = node.attrs.aligned;\n            }\n\n            if (_aligned === 'center') {\n              start += '\\n\\n\\\\begin{center}';\n              end = '\\n\\n\\\\end{center}\\n' + end;\n            } else if (_aligned === 'right') {\n              start += '\\n\\n{\\\\raggedleft'; // This is not a typo - raggedleft = aligned: right\n\n              end = '\\n\\n}\\n';\n            } // aligned === 'left' is default\n\n\n            start += \"\\n\\n\\\\begin{tabu} to \".concat(node.attrs.width === '100' ? '' : parseInt(node.attrs.width) / 100, \"\\\\textwidth { |\").concat('X|'.repeat(columns), \" }\\n\\\\hline\\n\\n\");\n            end = \"\\\\hline\\n\\n\\\\end{tabu}\" + end;\n            this.features.tables = true;\n          }\n\n          break;\n\n        case 'table_row':\n          end += ' \\\\\\\\\\n';\n          break;\n\n        case 'table_cell':\n        case 'table_header':\n          if (node.attrs.colspan > 1) {\n            start += \"\\\\multicolumn{\".concat(node.attrs.colspan, \"}{c}{\");\n            end += '}';\n          } // TODO: these multirow outputs don't work very well with longer text.\n          // If there is another alternative, please change!\n\n\n          if (node.attrs.rowspan > 1) {\n            start += \"\\\\multirow{\".concat(node.attrs.rowspan, \"}{*}{\");\n            end += '}';\n            this.features.rowspan = true;\n          }\n\n          end += ' & ';\n          break;\n\n        case 'equation':\n          content += \"$\".concat(node.attrs.equation, \"$\");\n          break;\n\n        case 'hard_break':\n          content += '\\n\\n';\n          break;\n\n        default:\n          break;\n      }\n\n      if (node.content) {\n        node.content.forEach(function (child) {\n          content += _this2.walkJson(child, options);\n        });\n      }\n\n      if (placeFootnotesAfterBlock && options.unplacedFootnotes && options.unplacedFootnotes.length) {\n        // There are footnotes that needed to be placed behind the node.\n        // This happens in the case of headlines and lists.\n        end += \"\\\\addtocounter{footnote}{-\".concat(options.unplacedFootnotes.length, \"}\");\n        options.unplacedFootnotes.forEach(function (footnote) {\n          end += '\\\\stepcounter{footnote}\\n';\n          end += '\\\\footnotetext{';\n          var fnContent = '';\n          footnote.forEach(function (footPar) {\n            fnContent += _this2.walkJson(footPar, options);\n          });\n          end += fnContent.replace(/^\\s+|\\s+$/g, '');\n          end += '}';\n        });\n        options.unplacedFootnotes = [];\n      }\n\n      if (['table_cell', 'table_header'].includes(node.type) && node.attrs.rowspan > 1) {\n        // \\multirow doesn't allow multiple paragraphs.\n        content = content.trim().replace(/\\n\\n/g, ' \\\\\\\\ ');\n      }\n\n      return start + content + end;\n    } // The database doesn't ensure that citation keys are unique.\n    // So here we need to make sure that the same key is not used twice in one\n    // document.\n\n  }, {\n    key: \"createUniqueCitationKey\",\n    value: function createUniqueCitationKey(suggestedKey) {\n      var _this3 = this;\n\n      var usedKeys = Object.keys(this.usedBibDB).map(function (key) {\n        return _this3.usedBibDB[key].entry_key;\n      });\n\n      if (usedKeys.includes(suggestedKey)) {\n        suggestedKey += 'X';\n        return this.createUniqueCitationKey(suggestedKey);\n      } else {\n        return suggestedKey;\n      }\n    }\n  }, {\n    key: \"postProcess\",\n    value: function postProcess(latex) {\n      return latex // join blocks of the same type that follow oneanother.\n      .replace(/\\\\end{code}\\n\\n\\\\begin{code}\\n\\n/g, '').replace(/\\\\end{quote}\\n\\n\\\\begin{quote}\\n\\n/g, '') // Remove the last divider in any any table row.\n      .replace(/& {2}\\\\\\\\/g, '\\\\\\\\') // Remove new lines between table cells.\n      .replace(/\\n & \\n\\n/g, ' & ') // Remove new lines within itemization\n      .replace(/\\\\item \\n\\n/g, '\\\\item ');\n    }\n  }, {\n    key: \"assembleEpilogue\",\n    value: function assembleEpilogue() {\n      var epilogue = '';\n      var settings = this.exporter.doc.settings,\n          bibliographyHeader = settings.bibliography_header[settings.language] || _schema_i18n__WEBPACK_IMPORTED_MODULE_1__[\"BIBLIOGRAPHY_HEADERS\"][settings.language];\n\n      if (this.features.citations) {\n        epilogue += \"\\n\\n\\\\printbibliography[title={\".concat(Object(_escape_latex__WEBPACK_IMPORTED_MODULE_0__[\"escapeLatexText\"])(bibliographyHeader), \"}]\");\n      }\n\n      return epilogue;\n    }\n  }, {\n    key: \"assemblePreamble\",\n    value: function assemblePreamble() {\n      var preamble = '';\n\n      if (this.features.subtitle) {\n        preamble += \"\\n                \\n\\\\usepackage{titling}\\n                \\n\\\\newcommand{\\\\subtitle}[1]{%\\n                    \\n\\t\\\\posttitle{%\\n                        \\n\\t\\t\\\\par\\\\end{center}\\n                        \\n\\t\\t\\\\begin{center}\\\\large#1\\\\end{center}\\n                        \\n\\t\\t\\\\vskip 0.5em}%\\n                }\\n            \";\n      }\n\n      if (this.features.authors) {\n        preamble += \"\\n                \\n\\\\usepackage{authblk}\\n                \\n\\\\makeatletter\\n                \\n\\\\let\\\\@fnsymbol\\\\@alph\\n                \\n\\\\makeatother\\n            \";\n      }\n\n      if (this.features.keywords) {\n        preamble += \"\\n                \\n\\\\def\\\\keywords{\\\\vspace{.5em}\\n                \\n{\\\\textit{Keywords}:\\\\,\\\\relax%\\n                \\n}}\\n                \\n\\\\def\\\\endkeywords{\\\\par}\\n                \\n\\\\newcommand{\\\\sep}{, }\\n            \";\n      }\n\n      if (this.features.hyperlinks) {\n        preamble += \"\\n\\\\usepackage{hyperref}\";\n      }\n\n      if (this.features.citations) {\n        preamble += \"\\n                \\n\\\\usepackage[backend=biber,hyperref=false,citestyle=authoryear,bibstyle=authoryear]{biblatex}\\n                \\n\\\\bibliography{bibliography}\\n            \";\n      }\n\n      if (this.features.SVGs) {\n        preamble += \"\\n\\\\usepackage{svg}\";\n      }\n\n      if (this.features.images) {\n        preamble += \"\\n\\\\usepackage{graphicx}\"; // The following scales graphics down to text width, but not scaling them up if they are smaller\n\n        preamble += \"\\n                \\n\\\\usepackage{calc}\\n                \\n\\\\newlength{\\\\imgwidth}\\n                \\n\\\\newcommand\\\\scaledgraphics[2]{%\\n                \\n\\\\settowidth{\\\\imgwidth}{\\\\includegraphics{#1}}%\\n                \\n\\\\setlength{\\\\imgwidth}{\\\\minof{\\\\imgwidth}{#2\\\\textwidth}}%\\n                \\n\\\\includegraphics[width=\\\\imgwidth,height=\\\\textheight,keepaspectratio]{#1}%\\n                \\n}\\n            \";\n      }\n\n      if (this.features.tables) {\n        preamble += \"\\n\\\\usepackage{tabu}\";\n      }\n\n      if (this.features.rowspan) {\n        preamble += \"\\n\\\\usepackage{multirow}\";\n      }\n\n      return preamble;\n    }\n  }, {\n    key: \"docDeclaration\",\n    get: function get() {\n      return '\\\\documentclass{article}\\n';\n    }\n  }]);\n\n  return LatexExporterConvert;\n}();\n\n//# sourceURL=webpack:///./js/modules/exporter/latex/convert.js?");

/***/ }),

/***/ "./js/modules/exporter/latex/escape_latex.js":
/*!***************************************************!*\
  !*** ./js/modules/exporter/latex/escape_latex.js ***!
  \***************************************************/
/*! exports provided: escapeLatexText */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"escapeLatexText\", function() { return escapeLatexText; });\n/* eslint-disable no-control-regex */\nvar escapeLatexText = function escapeLatexText(text) {\n  return text // Remove line breaks\n  .replace(/\\r|\\n/g, '') // Escape characters that are protected in some way.\n  .replace(/\\\\\\\\/g, '\\\\textbackslash').replace(/\\{/g, '\\\\{').replace(/\\}/g, '\\\\}').replace(/\\\\\\\\textbackslash/g, '\\\\textbackslash{}').replace(/\\^/g, '\\\\textasciicircum{}').replace(/\\$/g, '\\\\$').replace(/_/g, '\\\\_').replace(/~/g, '\\\\textasciitilde{}').replace(/#/g, '\\\\#').replace(/%/g, '\\\\%').replace(/&/g, '\\\\&') // Remove control characters that somehow have ended up in the document\n  .replace(/\\u000B/g, '').replace(/\\u000C/g, '').replace(/\\u000E/g, '').replace(/\\u000F/g, '');\n};\n\n//# sourceURL=webpack:///./js/modules/exporter/latex/escape_latex.js?");

/***/ }),

/***/ "./js/modules/exporter/latex/index.js":
/*!********************************************!*\
  !*** ./js/modules/exporter/latex/index.js ***!
  \********************************************/
/*! exports provided: LatexExporter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LatexExporter\", function() { return LatexExporter; });\n/* harmony import */ var biblatex_csl_converter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! biblatex-csl-converter */ \"./node_modules/biblatex-csl-converter/src/index.js\");\n/* harmony import */ var downloadjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! downloadjs */ \"./node_modules/downloadjs/download.js\");\n/* harmony import */ var downloadjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(downloadjs__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _tools_file__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/file */ \"./js/modules/exporter/tools/file.js\");\n/* harmony import */ var _tools_doc_contents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tools/doc_contents */ \"./js/modules/exporter/tools/doc_contents.js\");\n/* harmony import */ var _convert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./convert */ \"./js/modules/exporter/latex/convert.js\");\n/* harmony import */ var _tools_zip__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tools/zip */ \"./js/modules/exporter/tools/zip.js\");\n/* harmony import */ var _readme__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./readme */ \"./js/modules/exporter/latex/readme.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\n\n\n/*\n Exporter to LaTeX\n*/\n\nvar LatexExporter =\n/*#__PURE__*/\nfunction () {\n  function LatexExporter(doc, bibDB, imageDB) {\n    _classCallCheck(this, LatexExporter);\n\n    this.doc = doc;\n    this.bibDB = bibDB;\n    this.imageDB = imageDB;\n    this.docContents = false;\n    this.zipFileName = false;\n    this.textFiles = [];\n    this.httpFiles = [];\n  }\n\n  _createClass(LatexExporter, [{\n    key: \"init\",\n    value: function init() {\n      var _this = this;\n\n      this.zipFileName = \"\".concat(Object(_tools_file__WEBPACK_IMPORTED_MODULE_2__[\"createSlug\"])(this.doc.title), \".latex.zip\");\n      this.docContents = Object(_tools_doc_contents__WEBPACK_IMPORTED_MODULE_3__[\"fixTables\"])(Object(_tools_doc_contents__WEBPACK_IMPORTED_MODULE_3__[\"removeHidden\"])(this.doc.contents));\n      this.converter = new _convert__WEBPACK_IMPORTED_MODULE_4__[\"LatexExporterConvert\"](this, this.imageDB, this.bibDB);\n      this.conversion = this.converter.init(this.docContents);\n\n      if (Object.keys(this.conversion.usedBibDB).length > 0) {\n        var bibExport = new biblatex_csl_converter__WEBPACK_IMPORTED_MODULE_0__[\"BibLatexExporter\"](this.conversion.usedBibDB);\n        this.textFiles.push({\n          filename: 'bibliography.bib',\n          contents: bibExport.parse()\n        });\n      }\n\n      this.textFiles.push({\n        filename: 'document.tex',\n        contents: this.conversion.latex\n      });\n      this.textFiles.push({\n        filename: 'README.txt',\n        contents: _readme__WEBPACK_IMPORTED_MODULE_6__[\"readMe\"]\n      });\n      this.conversion.imageIds.forEach(function (id) {\n        _this.httpFiles.push({\n          filename: _this.imageDB.db[id].image.split('/').pop(),\n          url: _this.imageDB.db[id].image\n        });\n      });\n      var zipper = new _tools_zip__WEBPACK_IMPORTED_MODULE_5__[\"ZipFileCreator\"](this.textFiles, this.httpFiles);\n      zipper.init().then(function (blob) {\n        return downloadjs__WEBPACK_IMPORTED_MODULE_1___default()(blob, _this.zipFileName, 'application/zip');\n      });\n    }\n  }]);\n\n  return LatexExporter;\n}();\n\n//# sourceURL=webpack:///./js/modules/exporter/latex/index.js?");

/***/ }),

/***/ "./js/modules/exporter/latex/readme.js":
/*!*********************************************!*\
  !*** ./js/modules/exporter/latex/readme.js ***!
  \*********************************************/
/*! exports provided: readMe */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"readMe\", function() { return readMe; });\nvar readMe = \"In order to compile the latex file, you need to use at least TeXLive 2016. If\\nthere are citations, you additionally need Biber 2.7/BibLaTeX 3.7.\\n\\nOn Ubuntu 18.04+ install the packages texlive-latex-base and\\ntexlive-latex-extra.\\n\\nExtract all the files included in this ZIP into a folder.\\nRun then these commands to create a PDF from within this folder:\\n\\n> lualatex document\\n\\nIf there are citations, continue with these commands:\\n\\n> biber document\\n> lualatex document\\n\\nLook at the output messages to determine whether you need to run laluatex again.\\n\";\n\n//# sourceURL=webpack:///./js/modules/exporter/latex/readme.js?");

/***/ }),

/***/ "./js/modules/exporter/tools/doc_contents.js":
/*!***************************************************!*\
  !*** ./js/modules/exporter/tools/doc_contents.js ***!
  \***************************************************/
/*! exports provided: removeHidden, descendantNodes, textContent, fixTables */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeHidden\", function() { return removeHidden; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"descendantNodes\", function() { return descendantNodes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"textContent\", function() { return textContent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fixTables\", function() { return fixTables; });\n// Return a json that is the same as the existing json, but with all parts\n// marked as hidden removed.\nvar removeHidden = function removeHidden(node) {\n  var leaveStub = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var returnNode = {};\n  Object.keys(node).forEach(function (key) {\n    if (key !== 'content') {\n      returnNode[key] = node[key];\n    }\n  });\n\n  if (node.attrs && node.attrs.hidden) {\n    if (leaveStub) {\n      return returnNode;\n    } else {\n      return false;\n    }\n  }\n\n  if (node.content) {\n    returnNode.content = [];\n    node.content.forEach(function (child) {\n      var cleanedChild = removeHidden(child, leaveStub);\n\n      if (cleanedChild) {\n        returnNode.content.push(cleanedChild);\n      }\n    });\n  }\n\n  return returnNode;\n};\nvar descendantNodes = function descendantNodes(node) {\n  var returnValue = [node];\n\n  if (node.content) {\n    node.content.forEach(function (childNode) {\n      returnValue = returnValue.concat(descendantNodes(childNode));\n    });\n  }\n\n  return returnValue;\n};\nvar textContent = function textContent(node) {\n  return descendantNodes(node).reduce(function (returnString, subNode) {\n    if (subNode.text) {\n      returnString += subNode.text;\n    }\n\n    return returnString;\n  }, '');\n}; // PM/HTML don't have cells that have been covered, but in ODT/DOCX, these cells\n// need to be present. So we add them.\n\nvar addCoveredTableCells = function addCoveredTableCells(node) {\n  var columns = node.content[0].content.reduce(function (columns, cell) {\n    return columns + cell.attrs.colspan;\n  }, 0);\n  var rows = node.content.length; // Add empty cells for col/rowspan\n\n  var fixedTableMatrix = Array.apply(0, {\n    length: rows\n  }).map(function (_item) {\n    return {\n      type: 'table_row',\n      content: Array.apply(0, {\n        length: columns\n      })\n    };\n  });\n  var rowIndex = -1;\n  node.content.forEach(function (row) {\n    var columnIndex = 0;\n    rowIndex++;\n\n    if (!row.content) {\n      return;\n    }\n\n    row.content.forEach(function (cell) {\n      while (fixedTableMatrix[rowIndex].content[columnIndex]) {\n        columnIndex++;\n      }\n\n      for (var i = 0; i < cell.attrs.rowspan; i++) {\n        for (var j = 0; j < cell.attrs.colspan; j++) {\n          var fixedCell = void 0;\n\n          if (i === 0 && j === 0) {\n            fixedCell = cell;\n          } else {\n            fixedCell = {\n              type: 'table_cell',\n              attrs: {\n                rowspan: cell.attrs.rowspan > 1 ? 0 : 1,\n                colspan: cell.attrs.colspan > 1 ? 0 : 1\n              }\n            };\n          }\n\n          fixedTableMatrix[rowIndex + i].content[columnIndex + j] = fixedCell;\n        }\n      }\n    });\n  });\n  node.content = fixedTableMatrix;\n};\n\nvar fixTables = function fixTables(node) {\n  if (node.type === 'table') {\n    addCoveredTableCells(node);\n  }\n\n  if (node.content) {\n    node.content.forEach(function (child) {\n      return fixTables(child);\n    });\n  }\n\n  return node;\n};\n\n//# sourceURL=webpack:///./js/modules/exporter/tools/doc_contents.js?");

/***/ })

}]);